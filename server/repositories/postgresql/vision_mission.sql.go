// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: vision_mission.sql

package postgresql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteVisionMission = `-- name: DeleteVisionMission :execrows
UPDATE
    vision_mission
SET
    deleted_at = $1
WHERE
    id = $2
AND
    deleted_at IS NULL
`

type DeleteVisionMissionParams struct {
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	ID        string             `json:"id"`
}

func (q *Queries) DeleteVisionMission(ctx context.Context, arg DeleteVisionMissionParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteVisionMission, arg.DeletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findAllVisionMissions = `-- name: FindAllVisionMissions :many
SELECT
    id,
    vision,
    mission,
    author,
    created_at
FROM
    vision_mission
WHERE
    deleted_at IS NULL
ORDER BY
    created_at DESC
`

type FindAllVisionMissionsRow struct {
	ID        string             `json:"id"`
	Vision    string             `json:"vision"`
	Mission   string             `json:"mission"`
	Author    string             `json:"author"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) FindAllVisionMissions(ctx context.Context) ([]FindAllVisionMissionsRow, error) {
	rows, err := q.db.Query(ctx, findAllVisionMissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllVisionMissionsRow{}
	for rows.Next() {
		var i FindAllVisionMissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Vision,
			&i.Mission,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestVisionMission = `-- name: FindLatestVisionMission :one
SELECT
    id,
    vision,
    mission,
    author,
    created_at,
    updated_at
FROM
    vision_mission
WHERE
    deleted_at IS NULL
ORDER BY
    created_at DESC
LIMIT 1
`

type FindLatestVisionMissionRow struct {
	ID        string             `json:"id"`
	Vision    string             `json:"vision"`
	Mission   string             `json:"mission"`
	Author    string             `json:"author"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) FindLatestVisionMission(ctx context.Context) (FindLatestVisionMissionRow, error) {
	row := q.db.QueryRow(ctx, findLatestVisionMission)
	var i FindLatestVisionMissionRow
	err := row.Scan(
		&i.ID,
		&i.Vision,
		&i.Mission,
		&i.Author,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findVisionMissionByID = `-- name: FindVisionMissionByID :one
SELECT
    id,
    vision,
    mission,
    author,
    created_at,
    updated_at
FROM
    vision_mission
WHERE
    id = $1
AND
    deleted_at IS NULL
`

type FindVisionMissionByIDRow struct {
	ID        string             `json:"id"`
	Vision    string             `json:"vision"`
	Mission   string             `json:"mission"`
	Author    string             `json:"author"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) FindVisionMissionByID(ctx context.Context, id string) (FindVisionMissionByIDRow, error) {
	row := q.db.QueryRow(ctx, findVisionMissionByID, id)
	var i FindVisionMissionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Vision,
		&i.Mission,
		&i.Author,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertVisionMission = `-- name: InsertVisionMission :exec
INSERT INTO vision_mission(id, vision, mission, author, created_at)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type InsertVisionMissionParams struct {
	ID        string             `json:"id"`
	Vision    string             `json:"vision"`
	Mission   string             `json:"mission"`
	Author    string             `json:"author"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) InsertVisionMission(ctx context.Context, arg InsertVisionMissionParams) error {
	_, err := q.db.Exec(ctx, insertVisionMission,
		arg.ID,
		arg.Vision,
		arg.Mission,
		arg.Author,
		arg.CreatedAt,
	)
	return err
}

const updateVisionMission = `-- name: UpdateVisionMission :execrows
UPDATE
    vision_mission
SET
    vision = $1,
    mission = $2,
    updated_at = $3
WHERE
    id = $4
AND
    deleted_at IS NULL
`

type UpdateVisionMissionParams struct {
	Vision    string             `json:"vision"`
	Mission   string             `json:"mission"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	ID        string             `json:"id"`
}

func (q *Queries) UpdateVisionMission(ctx context.Context, arg UpdateVisionMissionParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateVisionMission,
		arg.Vision,
		arg.Mission,
		arg.UpdatedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
