// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: commodity.sql

package postgresql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCommodity = `-- name: DeleteCommodity :execrows
UPDATE
    commodities
SET
    deleted_at = $1
WHERE
    id = $2
AND
    deleted_at IS NULL
`

type DeleteCommodityParams struct {
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	ID        string             `json:"id"`
}

func (q *Queries) DeleteCommodity(ctx context.Context, arg DeleteCommodityParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCommodity, arg.DeletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findAllCommodities = `-- name: FindAllCommodities :many
SELECT
    id,
    name,
    price,
    unit,
    publish_date,
    commodity_type_id,
    author,
    created_at
FROM
    commodities
WHERE
    deleted_at IS NULL
ORDER BY
    name ASC
`

type FindAllCommoditiesRow struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Price           pgtype.Numeric     `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	CommodityTypeID string             `json:"commodity_type_id"`
	Author          string             `json:"author"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) FindAllCommodities(ctx context.Context) ([]FindAllCommoditiesRow, error) {
	rows, err := q.db.Query(ctx, findAllCommodities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllCommoditiesRow{}
	for rows.Next() {
		var i FindAllCommoditiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Unit,
			&i.PublishDate,
			&i.CommodityTypeID,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCommoditiesByType = `-- name: FindCommoditiesByType :many
SELECT
    id,
    name,
    price,
    unit,
    publish_date,
    commodity_type_id,
    author,
    created_at
FROM
    commodities
WHERE
    commodity_type_id = $1
AND
    deleted_at IS NULL
ORDER BY
    name ASC
`

type FindCommoditiesByTypeRow struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Price           pgtype.Numeric     `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	CommodityTypeID string             `json:"commodity_type_id"`
	Author          string             `json:"author"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) FindCommoditiesByType(ctx context.Context, commodityTypeID string) ([]FindCommoditiesByTypeRow, error) {
	rows, err := q.db.Query(ctx, findCommoditiesByType, commodityTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindCommoditiesByTypeRow{}
	for rows.Next() {
		var i FindCommoditiesByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Unit,
			&i.PublishDate,
			&i.CommodityTypeID,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCommodityByID = `-- name: FindCommodityByID :one
SELECT
    c.id,
    c.commodity_type_id,
    ct.description as commodity_type_name,
    c.name,
    c.price,
    c.unit,
    c.publish_date,
    c.description,
    c.author,
    c.created_at,
    c.updated_at
FROM
    commodities c
LEFT JOIN
    commodity_types ct ON c.commodity_type_id = ct.id AND ct.deleted_at IS NULL
WHERE
    c.id = $1
AND
    c.deleted_at IS NULL
`

type FindCommodityByIDRow struct {
	ID                string             `json:"id"`
	CommodityTypeID   string             `json:"commodity_type_id"`
	CommodityTypeName pgtype.Text        `json:"commodity_type_name"`
	Name              string             `json:"name"`
	Price             pgtype.Numeric     `json:"price"`
	Unit              string             `json:"unit"`
	PublishDate       pgtype.Date        `json:"publish_date"`
	Description       pgtype.Text        `json:"description"`
	Author            string             `json:"author"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) FindCommodityByID(ctx context.Context, id string) (FindCommodityByIDRow, error) {
	row := q.db.QueryRow(ctx, findCommodityByID, id)
	var i FindCommodityByIDRow
	err := row.Scan(
		&i.ID,
		&i.CommodityTypeID,
		&i.CommodityTypeName,
		&i.Name,
		&i.Price,
		&i.Unit,
		&i.PublishDate,
		&i.Description,
		&i.Author,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findLatestCommodities = `-- name: FindLatestCommodities :many
SELECT
    id,
    name,
    price,
    unit,
    publish_date,
    commodity_type_id,
    author,
    created_at
FROM
    commodities
WHERE
    deleted_at IS NULL
ORDER BY
    publish_date DESC
`

type FindLatestCommoditiesRow struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Price           pgtype.Numeric     `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	CommodityTypeID string             `json:"commodity_type_id"`
	Author          string             `json:"author"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) FindLatestCommodities(ctx context.Context) ([]FindLatestCommoditiesRow, error) {
	rows, err := q.db.Query(ctx, findLatestCommodities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindLatestCommoditiesRow{}
	for rows.Next() {
		var i FindLatestCommoditiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Unit,
			&i.PublishDate,
			&i.CommodityTypeID,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCommodity = `-- name: InsertCommodity :exec
INSERT INTO commodities(id, name, price, unit, publish_date, description, commodity_type_id, author, created_at)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
`

type InsertCommodityParams struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Price           pgtype.Numeric     `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	Description     pgtype.Text        `json:"description"`
	CommodityTypeID string             `json:"commodity_type_id"`
	Author          string             `json:"author"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) InsertCommodity(ctx context.Context, arg InsertCommodityParams) error {
	_, err := q.db.Exec(ctx, insertCommodity,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.Unit,
		arg.PublishDate,
		arg.Description,
		arg.CommodityTypeID,
		arg.Author,
		arg.CreatedAt,
	)
	return err
}

const updateCommodity = `-- name: UpdateCommodity :execrows
UPDATE
    commodities
SET
    name = $1,
    price = $2,
    unit = $3,
    publish_date = $4,
    description = $5,
    commodity_type_id = $6,
    updated_at = $7
WHERE
    id = $8
AND
    deleted_at IS NULL
`

type UpdateCommodityParams struct {
	Name            string             `json:"name"`
	Price           pgtype.Numeric     `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	Description     pgtype.Text        `json:"description"`
	CommodityTypeID string             `json:"commodity_type_id"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ID              string             `json:"id"`
}

func (q *Queries) UpdateCommodity(ctx context.Context, arg UpdateCommodityParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateCommodity,
		arg.Name,
		arg.Price,
		arg.Unit,
		arg.PublishDate,
		arg.Description,
		arg.CommodityTypeID,
		arg.UpdatedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
