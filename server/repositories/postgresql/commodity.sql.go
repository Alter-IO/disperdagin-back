// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: commodity.sql

package postgresql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCommodity = `-- name: DeleteCommodity :execrows
UPDATE
    commodities
SET
    deleted_at = $1
WHERE
    id = $2
AND
    deleted_at IS NULL
`

type DeleteCommodityParams struct {
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	ID        pgtype.Text        `json:"id"`
}

func (q *Queries) DeleteCommodity(ctx context.Context, arg DeleteCommodityParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCommodity, arg.DeletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findAllCommodities = `-- name: FindAllCommodities :many
SELECT
    id,
    name,
    price,
    unit,
    publish_date,
    commodity_type_id,
    author,
    created_at
FROM
    commodities
WHERE
    deleted_at IS NULL
ORDER BY
    name ASC
`

type FindAllCommoditiesRow struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Price           interface{}        `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	CommodityTypeID string             `json:"commodity_type_id"`
	Author          string             `json:"author"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) FindAllCommodities(ctx context.Context) ([]FindAllCommoditiesRow, error) {
	rows, err := q.db.Query(ctx, findAllCommodities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllCommoditiesRow{}
	for rows.Next() {
		var i FindAllCommoditiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Unit,
			&i.PublishDate,
			&i.CommodityTypeID,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCommoditiesByType = `-- name: FindCommoditiesByType :many
SELECT
    id,
    name,
    price,
    unit,
    publish_date,
    commodity_type_id,
    author,
    created_at
FROM
    commodities
WHERE
    commodity_type_id = $1
AND
    deleted_at IS NULL
ORDER BY
    name ASC
`

type FindCommoditiesByTypeRow struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Price           interface{}        `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	CommodityTypeID string             `json:"commodity_type_id"`
	Author          string             `json:"author"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) FindCommoditiesByType(ctx context.Context, dollar_1 pgtype.Text) ([]FindCommoditiesByTypeRow, error) {
	rows, err := q.db.Query(ctx, findCommoditiesByType, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindCommoditiesByTypeRow{}
	for rows.Next() {
		var i FindCommoditiesByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Unit,
			&i.PublishDate,
			&i.CommodityTypeID,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCommodityByID = `-- name: FindCommodityByID :one
SELECT
    id,
    name,
    price,
    unit,
    publish_date,
    description,
    commodity_type_id,
    author,
    created_at,
    updated_at
FROM
    commodities
WHERE
    id = $1
AND
    deleted_at IS NULL
`

type FindCommodityByIDRow struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Price           interface{}        `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	Description     pgtype.Text        `json:"description"`
	CommodityTypeID string             `json:"commodity_type_id"`
	Author          string             `json:"author"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) FindCommodityByID(ctx context.Context, dollar_1 pgtype.Text) (FindCommodityByIDRow, error) {
	row := q.db.QueryRow(ctx, findCommodityByID, dollar_1)
	var i FindCommodityByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Unit,
		&i.PublishDate,
		&i.Description,
		&i.CommodityTypeID,
		&i.Author,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findLatestCommodities = `-- name: FindLatestCommodities :many
SELECT
    id,
    name,
    price,
    unit,
    publish_date,
    commodity_type_id,
    author,
    created_at
FROM
    commodities
WHERE
    deleted_at IS NULL
ORDER BY
    publish_date DESC
LIMIT $1
`

type FindLatestCommoditiesRow struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	Price           interface{}        `json:"price"`
	Unit            string             `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	CommodityTypeID string             `json:"commodity_type_id"`
	Author          string             `json:"author"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) FindLatestCommodities(ctx context.Context, dollar_1 pgtype.Int8) ([]FindLatestCommoditiesRow, error) {
	rows, err := q.db.Query(ctx, findLatestCommodities, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindLatestCommoditiesRow{}
	for rows.Next() {
		var i FindLatestCommoditiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Unit,
			&i.PublishDate,
			&i.CommodityTypeID,
			&i.Author,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCommodity = `-- name: InsertCommodity :exec
INSERT INTO commodities(id, name, price, unit, publish_date, description, commodity_type_id, author, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type InsertCommodityParams struct {
	Column1 pgtype.Text        `json:"column_1"`
	Column2 pgtype.Text        `json:"column_2"`
	Column3 pgtype.Numeric     `json:"column_3"`
	Column4 pgtype.Text        `json:"column_4"`
	Column5 pgtype.Date        `json:"column_5"`
	Column6 pgtype.Text        `json:"column_6"`
	Column7 pgtype.Text        `json:"column_7"`
	Column8 pgtype.Text        `json:"column_8"`
	Column9 pgtype.Timestamptz `json:"column_9"`
}

func (q *Queries) InsertCommodity(ctx context.Context, arg InsertCommodityParams) error {
	_, err := q.db.Exec(ctx, insertCommodity,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
	)
	return err
}

const updateCommodity = `-- name: UpdateCommodity :execrows
UPDATE
    commodities
SET
    name = $1,
    price = $2,
    unit = $3,
    publish_date = $4,
    description = $5,
    commodity_type_id = $6,
    updated_at = $7
WHERE
    id = $8
AND
    deleted_at IS NULL
`

type UpdateCommodityParams struct {
	Name            pgtype.Text        `json:"name"`
	Price           pgtype.Numeric     `json:"price"`
	Unit            pgtype.Text        `json:"unit"`
	PublishDate     pgtype.Date        `json:"publish_date"`
	Description     pgtype.Text        `json:"description"`
	CommodityTypeID pgtype.Text        `json:"commodity_type_id"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ID              pgtype.Text        `json:"id"`
}

func (q *Queries) UpdateCommodity(ctx context.Context, arg UpdateCommodityParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateCommodity,
		arg.Name,
		arg.Price,
		arg.Unit,
		arg.PublishDate,
		arg.Description,
		arg.CommodityTypeID,
		arg.UpdatedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
